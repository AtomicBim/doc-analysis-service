"""
Gradio-интерфейс для анализа проектной документации
в соответствии с требованиями технического задания
"""
import os
import json
import gradio as gr
from typing import Optional, Tuple
from pathlib import Path


# ============================
# КОНСТАНТЫ И КОНФИГУРАЦИЯ
# ============================

# Словарь примеров имен для валидации файлов
# Ссылка на словарь: https://example.com/naming-conventions (пример URL)
VALIDATION_EXAMPLES = {
    "technical_assignment": [
        "tz_project.docx", "tech_assignment.pdf", "tz_rd.docx",
        "tz_", "техническое_задание", "тз_"
    ],
    "documentation": [
        "documentation_fe.pdf", "docs_project.docx", "fe_docs.pdf",
        "documentation_", "docs_", "проектная_документация"
    ],
    "technical_requirements": [
        "_tu.docx", "_tu.pdf", "tech_requirements_",
        "технические_условия", "ту_"
    ]
}

# Стадии документации
STAGES = {
    "ГК": "Градостроительная концепция",
    "ФЭ": "Форэскизный проект",
    "ЭП": "Эскизный проект",
    "ПД": "Проектная документация (стадия П)",
    "РД": "Рабочая документация"
}

# Типы требований
REQUIREMENT_TYPES = {
    "ТЗ": "ТЗ на проектирование (общие требования)",
    "ТУ_РД": "ТУ на проектирование для РД",
    "ТУ_ПД": "ТУ на проектирование для ПД",
    "ТУ_ФЭ": "ТУ на проектирование для ФЭ",
    "ТУ_ЭП": "ТУ на проектирование для ЭП"
}

# Допустимые форматы файлов
ALLOWED_FORMATS = [".docx", ".pdf"]


# ============================
# СИСТЕМА ПРОМПТОВ
# ============================

PROMPTS = {
    "ГК": """<PROMPT_STAGE_PLACEHOLDER>
<анализ_документации_гк>
<задача>
Провести комплексный анализ соответствия проектной документации стадии Градостроительная концепция (ГК)
требованиям технического задания с проверкой концептуальных и планировочных решений.
</задача>
<критерии_оценки>
- Полностью исполнено: требование реализовано в полном объёме согласно ТЗ
- Частично исполнено: реализовано не полностью или с отклонениями
- Не исполнено: не отражено в проектных решениях
- Требует уточнения: недостаточно данных для однозначной оценки
</критерии_оценки>
</анализ_документации_гк>""",

    "ФЭ": """<PROMPT_STAGE_PLACEHOLDER>
<анализ_документации_фэ>
<задача>
Провести комплексный анализ соответствия проектной документации стадии Форэскиз (ФЭ) требованиям технического задания с детальной проверкой графических и текстовых материалов.
</задача>
<исходные_данные>
1. Проектная документация стадии ФЭ в формате PDF/DOCX, включающая:
  - Графическую часть (планы, разрезы, фасады, схемы)
  - Текстовую часть (пояснительная записка, спецификации, ведомости)
2. Техническое задание на разработку проектной документации стадии ФЭ
</исходные_данные>
<методика_анализа>
Для каждого требования ТЗ:
1. Определить его тип (архитектурно-планировочное, конструктивное, инженерное, экономическое)
2. Найти соответствующие проектные решения в документации
3. Оценить полноту и корректность исполнения
4. Выявить отклонения или неточности
</методика_анализа>
<критерии_оценки>
- Полностью исполнено: требование реализовано в полном объёме согласно ТЗ
- Частично исполнено: реализовано не полностью или с отклонениями
- Не исполнено: не отражено в проектных решениях
- Требует уточнения: недостаточно данных для однозначной оценки
</критерии_оценки>
<дополнительные_указания>
- При анализе графических материалов обращать внимание на масштабы, размеры, обозначения
- В текстовой части проверять соответствие технико-экономических показателей
- Фиксировать противоречия между разными разделами документации
- Отмечать отсутствие обязательных для стадии ФЭ материалов
</дополнительные_указания>
</анализ_документации_фэ>""",

    "ЭП": """<PROMPT_STAGE_PLACEHOLDER>
<анализ_документации_эп>
<задача>
Провести комплексный анализ соответствия проектной документации стадии Эскизный проект (ЭП)
требованиям технического задания с детальной проверкой архитектурных и объемно-планировочных решений.
</задача>
<критерии_оценки>
- Полностью исполнено: требование реализовано в полном объёме согласно ТЗ
- Частично исполнено: реализовано не полностью или с отклонениями
- Не исполнено: не отражено в проектных решениях
- Требует уточнения: недостаточно данных для однозначной оценки
</критерии_оценки>
</анализ_документации_эп>""",

    "ПД": """<PROMPT_STAGE_PLACEHOLDER>
<анализ_документации_пд>
<задача>
Провести комплексный анализ соответствия проектной документации стадии Проектная документация (ПД)
требованиям технического задания и технических условий с проверкой всех разделов и инженерных систем.
</задача>
<критерии_оценки>
- Полностью исполнено: требование реализовано в полном объёме согласно ТЗ/ТУ
- Частично исполнено: реализовано не полностью или с отклонениями
- Не исполнено: не отражено в проектных решениях
- Требует уточнения: недостаточно данных для однозначной оценки
</критерии_оценки>
<дополнительные_указания>
- Проверять соответствие нормам и стандартам
- Контролировать полноту состава проектной документации
- Проверять согласованность между разделами
</дополнительные_указания>
</анализ_документации_пд>""",

    "РД": """<PROMPT_STAGE_PLACEHOLDER>
<анализ_документации_рд>
<задача>
Провести комплексный анализ соответствия рабочей документации (РД) требованиям технического задания
и технических условий с проверкой детализации решений для строительства.
</задача>
<критерии_оценки>
- Полностью исполнено: требование реализовано в полном объёме согласно ТЗ/ТУ
- Частично исполнено: реализовано не полностью или с отклонениями
- Не исполнено: не отражено в проектных решениях
- Требует уточнения: недостаточно данных для однозначной оценки
</критерии_оценки>
<дополнительные_указания>
- Проверять достаточную детализацию для производства работ
- Контролировать наличие рабочих чертежей и спецификаций
- Проверять соответствие ПД и РД
</дополнительные_указания>
</анализ_документации_рд>"""
}

# Встроенные требования для ФЭ и ЭП
EMBEDDED_REQUIREMENTS = {
    "ТУ_ФЭ": "Встроенные технические условия для стадии ФЭ: базовые требования к форэскизному проекту согласно стандартам компании.",
    "ТУ_ЭП": "Встроенные технические условия для стадии ЭП: требования к эскизному проекту, включая архитектурные и объемно-планировочные решения."
}


# ============================
# ФУНКЦИИ ВАЛИДАЦИИ
# ============================

def validate_file_format(filename: str) -> Tuple[bool, str]:
    """
    Валидация формата файла

    Args:
        filename: имя файла

    Returns:
        (успех, сообщение об ошибке)
    """
    if not filename:
        return False, "Файл не загружен"

    file_ext = Path(filename).suffix.lower()
    if file_ext not in ALLOWED_FORMATS:
        return False, f"Неподдерживаемый формат файла. Разрешены только: {', '.join(ALLOWED_FORMATS)}"

    return True, ""


def validate_file_by_name(filename: str, file_type: str) -> Tuple[bool, str]:
    """
    Валидация файла по имени на основе словаря примеров

    Args:
        filename: имя файла
        file_type: тип файла ("technical_assignment", "documentation", "technical_requirements")

    Returns:
        (успех, сообщение об ошибке)
    """
    if not filename:
        return False, "Файл не загружен"

    # Проверка формата
    format_valid, format_error = validate_file_format(filename)
    if not format_valid:
        return False, format_error

    # Получаем имя без расширения и приводим к нижнему регистру
    file_basename = Path(filename).stem.lower()

    # Получаем список паттернов для данного типа
    patterns = VALIDATION_EXAMPLES.get(file_type, [])

    # Проверяем, содержит ли имя файла хотя бы один из паттернов
    matches = any(pattern.lower() in file_basename for pattern in patterns)

    if not matches:
        examples = ", ".join(VALIDATION_EXAMPLES[file_type][:3])
        return False, f"Имя файла не соответствует типу '{file_type}'. Примеры корректных имён: {examples}"

    return True, ""


def validate_all_inputs(
    tz_file,
    doc_file,
    stage: str,
    req_type: str,
    tu_file=None
) -> Tuple[bool, str]:
    """
    Комплексная валидация всех входных данных

    Returns:
        (успех, сообщение об ошибке в формате JSON если ошибка)
    """
    # Валидация ТЗ
    if tz_file is None:
        return False, json.dumps({"error": "Не загружен файл технического задания"}, ensure_ascii=False)

    valid, error = validate_file_by_name(tz_file.name, "technical_assignment")
    if not valid:
        return False, json.dumps({"error": f"Техническое задание: {error}"}, ensure_ascii=False)

    # Валидация документации
    if doc_file is None:
        return False, json.dumps({"error": "Не загружен файл документации"}, ensure_ascii=False)

    valid, error = validate_file_by_name(doc_file.name, "documentation")
    if not valid:
        return False, json.dumps({"error": f"Документация: {error}"}, ensure_ascii=False)

    # Валидация ТУ для РД и ПД
    if req_type in ["ТУ_РД", "ТУ_ПД"]:
        if tu_file is None:
            return False, json.dumps({"error": f"Для типа требований '{REQUIREMENT_TYPES[req_type]}' необходимо загрузить файл технических условий"}, ensure_ascii=False)

        valid, error = validate_file_by_name(tu_file.name, "technical_requirements")
        if not valid:
            return False, json.dumps({"error": f"Технические условия: {error}"}, ensure_ascii=False)

    return True, ""


# ============================
# ЛОГИКА ОБРАБОТКИ
# ============================

def process_documentation_analysis(
    tz_file,
    doc_file,
    stage: str,
    req_type: str,
    tu_file=None
) -> str:
    """
    Основная функция обработки и анализа документации

    Args:
        tz_file: файл технического задания
        doc_file: файл проектной документации
        stage: стадия документации
        req_type: тип требований
        tu_file: файл технических условий (опционально)

    Returns:
        Результат в формате Markdown таблицы или JSON с ошибкой
    """
    # Валидация входных данных
    valid, error_msg = validate_all_inputs(tz_file, doc_file, stage, req_type, tu_file)
    if not valid:
        return error_msg

    # Получение промпта для выбранной стадии
    prompt = PROMPTS.get(stage, PROMPTS["ФЭ"])

    # Формирование контекста требований
    requirements_context = ""
    if req_type in ["ТУ_ФЭ", "ТУ_ЭП"]:
        requirements_context = EMBEDDED_REQUIREMENTS[req_type]
    elif req_type in ["ТУ_РД", "ТУ_ПД"] and tu_file:
        requirements_context = f"Технические условия загружены из файла: {tu_file.name}"
    else:
        requirements_context = f"Техническое задание из файла: {tz_file.name}"

    # ЗАГЛУШКА: В реальной системе здесь должна быть интеграция с LLM
    # Для демонстрации возвращаем пример таблицы
    result_table = f"""
## Результаты анализа документации

**Стадия:** {STAGES[stage]}
**Тип требований:** {REQUIREMENT_TYPES[req_type]}
**Техническое задание:** {Path(tz_file.name).name}
**Документация:** {Path(doc_file.name).name}
**Требования:** {requirements_context}

---

| № | Требование из ТЗ | Статус исполнения | Достоверность (%) | Описание решения | Ссылка (документ, лист/страница) | Выявленные несоответствия и комментарии | Рекомендации |
|---|------------------|-------------------|-------------------|------------------|----------------------------------|----------------------------------------|--------------|
| 1 | Площадь здания не менее 5000 м² | Исполнено | 95 | В разделе ПЗ указана общая площадь 5200 м² | ПЗ, стр. 12 | - | - |
| 2 | Этажность: не более 10 этажей | Частично исполнено | 80 | Основное здание - 9 этажей, пристройка - 11 этажей | АР, лист 3 | Пристройка превышает требование | Согласовать превышение этажности пристройки |
| 3 | Парковка на 100 машиномест | Не исполнено | 100 | В проекте предусмотрено 85 машиномест | ГП, лист 1 | Недостаточное количество парковочных мест | Увеличить количество машиномест до 100 |
| 4 | Класс энергоэффективности B+ | Требует уточнения | 50 | Расчет энергоэффективности не представлен | - | Отсутствует раздел расчета | Предоставить энергетический паспорт |

---

**Промпт для анализа:**
```
{prompt}
```

**Примечание:** Это демонстрационный результат. В реальной системе здесь будет результат обработки LLM-моделью.
"""

    return result_table


def update_tu_visibility(req_type: str):
    """
    Обновление видимости поля загрузки ТУ в зависимости от типа требований

    Args:
        req_type: тип требований

    Returns:
        gr.update для компонента загрузки ТУ
    """
    if req_type in ["ТУ_РД", "ТУ_ПД"]:
        return gr.update(visible=True)
    else:
        return gr.update(visible=False)


# ============================
# GRADIO ИНТЕРФЕЙС
# ============================

def create_interface():
    """Создание Gradio интерфейса"""

    with gr.Blocks(title="Анализ проектной документации", theme=gr.themes.Soft()) as interface:
        gr.Markdown("""
        # 📋 Анализ соответствия проектной документации техническому заданию

        Система автоматического анализа проектной документации на соответствие требованиям ТЗ/ТУ
        """)

        with gr.Row():
            # Левая колонка - загрузка файлов
            with gr.Column(scale=1):
                gr.Markdown("### 📁 Загрузка файлов")

                tz_file = gr.File(
                    label="Техническое задание (ТЗ)",
                    file_types=[".docx", ".pdf"],
                    type="filepath"
                )
                gr.Markdown("*Принимаются файлы: .docx, .pdf*")

                doc_file = gr.File(
                    label="Проектная документация",
                    file_types=[".docx", ".pdf"],
                    type="filepath"
                )
                gr.Markdown("*Принимаются файлы: .docx, .pdf*")

                tu_file = gr.File(
                    label="Технические условия (ТУ)",
                    file_types=[".docx", ".pdf"],
                    type="filepath",
                    visible=False
                )
                gr.Markdown("*Загружается автоматически для стадий РД и ПД*")

            # Правая колонка - параметры анализа
            with gr.Column(scale=1):
                gr.Markdown("### ⚙️ Параметры анализа")

                stage = gr.Radio(
                    choices=list(STAGES.keys()),
                    label="Стадия документации",
                    value="ФЭ",
                    info="Выберите стадию разработки проектной документации"
                )

                req_type = gr.Radio(
                    choices=list(REQUIREMENT_TYPES.keys()),
                    label="Тип требований",
                    value="ТЗ",
                    info="Выберите тип требований для анализа"
                )

                # Информационный блок
                gr.Markdown("""
                **ℹ️ Справка:**
                - **ГК** - Градостроительная концепция
                - **ФЭ** - Форэскизный проект (встроенные ТУ)
                - **ЭП** - Эскизный проект (встроенные ТУ)
                - **ПД** - Проектная документация (требуется загрузка ТУ)
                - **РД** - Рабочая документация (требуется загрузка ТУ)
                """)

        # Кнопка запуска анализа
        analyze_btn = gr.Button("🔍 Выполнить анализ", variant="primary", size="lg")

        # Область вывода результатов
        gr.Markdown("### 📊 Результаты анализа")
        output = gr.Markdown(label="Результаты")

        # Связывание событий
        req_type.change(
            fn=update_tu_visibility,
            inputs=[req_type],
            outputs=[tu_file]
        )

        analyze_btn.click(
            fn=process_documentation_analysis,
            inputs=[tz_file, doc_file, stage, req_type, tu_file],
            outputs=[output]
        )

        # Примеры использования
        gr.Markdown("""
        ---
        ### 📚 Примеры корректных имён файлов

        **Техническое задание:**
        - `tz_project.docx`, `tech_assignment.pdf`, `tz_rd.docx`

        **Документация:**
        - `documentation_fe.pdf`, `docs_project.docx`, `fe_docs.pdf`

        **Технические условия:**
        - `requirements_tu.docx`, `project_tu.pdf`, `tech_requirements.pdf`

        *Словарь примеров для валидации: [naming-conventions](https://example.com/naming-conventions)*
        """)

    return interface


# ============================
# ЗАПУСК ПРИЛОЖЕНИЯ
# ============================

if __name__ == "__main__":
    print("🚀 Запуск приложения анализа проектной документации...")

    interface = create_interface()

    # Запуск на всех интерфейсах
    interface.launch(
        server_name="0.0.0.0",
        server_port=7860,
        share=False
    )
