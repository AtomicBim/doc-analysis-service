# 🔍 Алгоритм извлечения номера листа чертежа

## 📍 STAGE 1: Извлечение метаданных страниц

**Когда:** Самый первый этап анализа, сразу после загрузки PDF  
**Где:** Функция `extract_page_metadata()` в `api-service/analysis_api_hybrid.py` (строки 189-370)  
**Цель:** Извлечь номер листа, название, раздел и тип чертежа для КАЖДОЙ страницы PDF

---

## 🎯 Пошаговый алгоритм

### **ШАГ 1: Вырезка ключевых областей из страницы PDF**

Для каждой страницы вырезаются **4 ключевые области**, где может быть номер листа:

```
┌─────────────────────────────────────────┐
│  HEADER (весь заголовок)                │ ← Область 1: header_crop
│  0-10% по высоте                        │
├─────────────────────────────────────┬───┤
│                                     │ T │ ← Область 2: top_right_crop
│                                     │ O │    (правый верхний угол)
│                                     │ P │    70-100% ширины, 0-15% высоты
│         ОСНОВНОЙ ЧЕРТЕЖ             │   │
│                                     │   │
│                                     │   │
│                                     │   │
│                                     │   │
├─────────────────────────────────────┴───┤
│           BOTTOM CENTER                 │ ← Область 3: bottom_center_crop
│           "Лист 26"                     │    (для текста "Лист N")
│           92-100% по высоте             │    30-70% ширины
├─────────────────────────┬───────────────┤
│                         │   ШТАМП ГОСТ  │ ← Область 4: stamp_crop
│                         │   АР-03       │    (правый нижний)
│                         │               │    70-100% ширины, 80-100% высоты
└─────────────────────────┴───────────────┘
```

#### Координаты областей (из `config.py`):

```python
# 1. ШТАМП (правый нижний угол) - ГЛАВНОЕ МЕСТО ДЛЯ НОМЕРА
STAGE1_STAMP_CROP = {
    'left': 0.7,   # 70% от ширины
    'top': 0.8,    # 80% от высоты
    'right': 1.0,  # 100% ширины
    'bottom': 1.0  # 100% высоты
}

# 2. ПРАВЫЙ ВЕРХНИЙ УГОЛ (иногда тут есть номер)
STAGE1_TOP_RIGHT_CROP = {
    'left': 0.7,
    'top': 0.0,
    'right': 1.0,
    'bottom': 0.15
}

# 3. ЗАГОЛОВОК (название листа)
STAGE1_HEADER_CROP = {
    'left': 0.0,
    'top': 0.0,
    'right': 1.0,
    'bottom': 0.1
}

# 4. СЕРЕДИНА ВНИЗУ (для "Лист N")
STAGE1_BOTTOM_CENTER_CROP = {
    'left': 0.3,
    'top': 0.92,
    'right': 0.7,
    'bottom': 1.0
}
```

---

### **ШАГ 2: Объединение вырезок в одно изображение**

Код объединяет все 4 области в **одно компактное изображение** для экономии токенов:

```python
# Создаем combined image размером (width × 55% height)
combined = Image.new('RGB', (width, int(height * 0.55)))

# Размещаем вырезки:
combined.paste(header_crop, (0, 0))                           # Сверху
combined.paste(top_right_crop, (int(width * 0.7), int(height * 0.1)))
combined.paste(bottom_center_crop, (int(width * 0.3), int(height * 0.2)))
combined.paste(stamp_crop, (int(width * 0.7), int(height * 0.3)))  # Ниже
```

**Результат:** Компактное изображение с ключевыми областями для анализа

---

### **ШАГ 3: Отправка в Vision API с промптом**

Изображения отправляются в **OpenAI Vision API** с промптом из `prompts/stage1_metadata_extraction_prompt.txt`:

```python
content = [
    {"type": "text", "text": STAGE_PROMPTS["stage1_metadata"]},
    {"type": "text", "text": "\n--- Страница 1 ---"},
    {"type": "image_url", "image_url": {"url": "data:image/jpeg;base64,...", "detail": "low"}},
    {"type": "text", "text": "\n--- Страница 2 ---"},
    {"type": "image_url", "image_url": {"url": "data:image/jpeg;base64,...", "detail": "low"}},
    # ... и так далее
]

response = await client.chat.completions.create(
    model=OPENAI_MODEL,
    messages=[{"role": "user", "content": content}],
    response_format={"type": "json_object"},
    max_completion_tokens=4000
)
```

---

### **ШАГ 4: Приоритетный алгоритм извлечения номера**

Модель анализирует изображение по **приоритетной схеме**:

```
🔍 ПРИОРИТЕТ 1: ШТАМП (правый нижний угол)
   ├─ Стандартный штамп по ГОСТ
   ├─ Поле "Обозначение документа"
   └─ Примеры: "АР-01", "26", "ГП-1", "КР-03.1"
   
🔍 ПРИОРИТЕТ 2: СЕРЕДИНА ВНИЗУ
   ├─ Текст "Лист 26", "Л. 5", "Стр. 3"
   └─ Извлекается только число
   
🔍 ПРИОРИТЕТ 3: ПРАВЫЙ ВЕРХНИЙ УГОЛ
   ├─ Цифра в квадрате/рамке
   └─ Обычно одиночная цифра
   
❌ ПРИОРИТЕТ 4: Если ничего не найдено
   └─ Вернуть "N/A"
```

#### Инструкции для модели:
```
📋 ПРАВИЛА ОПРЕДЕЛЕНИЯ НОМЕРА:
- Если нашел номер в штампе → используй его (высший приоритет)
- Если штамп пустой/нечитаем → используй номер из середины внизу
- Если оба пусты → используй номер из правого верхнего угла
- Если все три места пусты → укажи "N/A"
```

---

### **ШАГ 5: Валидация и возврат результата**

Модель возвращает JSON с метаданными и **валидацией номера листа**:

```json
{
  "pages": [
    {
      "page": 1,
      "title": "План 1 этажа",
      "section": "АР",
      "type": "план",
      "sheet_number": "АР-01",           // ← ГЛАВНЫЙ РЕЗУЛЬТАТ
      "sheet_number_validation": {       // ← ВАЛИДАЦИЯ
        "matches": true,                 // Все источники совпадают?
        "found_in": ["stamp", "bottom_center"],  // Где найдено
        "values": ["АР-01", "1"]         // Что найдено в каждом месте
      }
    },
    {
      "page": 2,
      "title": "Схема электроснабжения",
      "section": "ЭС",
      "type": "схема",
      "sheet_number": "ЭС-03",
      "sheet_number_validation": {
        "matches": false,                // Несовпадение!
        "found_in": ["stamp", "top_right"],
        "values": ["ЭС-03", "2"]         // В штампе "ЭС-03", в углу "2"
      }
    }
  ]
}
```

---

## ⚙️ Технические детали

### Настройки качества (для быстрого анализа метаданных):
```python
STAGE1_DPI = 120           # Качество рендеринга (достаточно для OCR штампов)
STAGE1_QUALITY = 75        # JPEG качество (оптимально для текста)
STAGE1_MAX_PAGES = 150     # Максимум страниц для анализа
STAGE1_MAX_PAGES_PER_REQUEST = 30  # Батчинг для избежания rate limit
```

### Обработка больших документов:
```python
# Если страниц > 30 → разбиваем на батчи
if len(crops) > STAGE1_MAX_PAGES_PER_REQUEST:
    all_pages_metadata = []
    for batch_start in range(0, len(crops), STAGE1_MAX_PAGES_PER_REQUEST):
        batch_end = min(batch_start + STAGE1_MAX_PAGES_PER_REQUEST, len(crops))
        batch_crops = crops[batch_start:batch_end]
        
        # Анализируем батч...
        batch_metadata = analyze_batch(batch_crops)
        all_pages_metadata.extend(batch_metadata)
```

---

## 📊 Примеры извлечения

### **Пример 1: Стандартный чертеж с полным штампом**

Входные данные (вырезки):
```
┌─ HEADER ─────────────────────────┐
│ ЖИЛОЙ ДОМ. АРХИТЕКТУРНЫЕ РЕШЕНИЯ │
└──────────────────────────────────┘

┌─ STAMP ──────┐
│ АР           │
│ Лист 3 из 15 │
│ АР-03        │ ← НОМЕР ЛИСТА НАЙДЕН!
└──────────────┘
```

Результат:
```json
{
  "page": 3,
  "sheet_number": "АР-03",
  "sheet_number_validation": {
    "matches": true,
    "found_in": ["stamp", "bottom_center"],
    "values": ["АР-03", "3"]
  }
}
```

---

### **Пример 2: Чертеж без штампа (старый формат)**

Входные данные:
```
┌─ HEADER ─────────────┐
│ Генеральный план     │
└──────────────────────┘

┌─ STAMP ──┐
│ [пусто]  │ ← НЕТ ШТАМПА
└──────────┘

┌─ BOTTOM CENTER ──┐
│ Лист 26          │ ← НОМЕР ЗДЕСЬ!
└──────────────────┘
```

Результат (использован ПРИОРИТЕТ 2):
```json
{
  "page": 26,
  "sheet_number": "26",
  "sheet_number_validation": {
    "matches": true,
    "found_in": ["bottom_center"],
    "values": ["26"]
  }
}
```

---

### **Пример 3: Несовпадение номеров (ошибка сканирования)**

Входные данные:
```
┌─ STAMP ──────┐
│ КР-05.1      │ ← В штампе "КР-05.1"
└──────────────┘

┌─ TOP RIGHT ─┐
│    [3]      │ ← В углу "3"
└─────────────┘
```

Результат (выбран ПРИОРИТЕТ 1, но зафиксировано несовпадение):
```json
{
  "page": 5,
  "sheet_number": "КР-05.1",  // Используем из штампа
  "sheet_number_validation": {
    "matches": false,          // ⚠️ НЕСОВПАДЕНИЕ!
    "found_in": ["stamp", "top_right"],
    "values": ["КР-05.1", "3"]
  }
}
```

---

## 🔄 Использование результата

### В STAGE 2 (оценка релевантности):
```python
# Используется для описания страниц
pages_description = "\n".join([
    f"Страница {p['page']}: {p.get('title', 'N/A')} [{p.get('section', 'N/A')}] - {p.get('type', 'N/A')}"
    for p in pages_metadata
])
```

### В STAGE 3 (детальный анализ):
```python
# Создается mapping для подписей к изображениям
page_to_sheet_mapping = {}
for page_meta in pages_metadata:
    pdf_page = page_meta.get('page')           # 5
    sheet_num = page_meta.get('sheet_number')  # "АР-03"
    page_to_sheet_mapping[pdf_page] = sheet_num

# Результат: {5: "АР-03", 12: "КЖ-12", ...}
```

### В UI (навигация):
```python
# Создается reverse mapping для навигации
sheet_to_pdf_mapping = {}
for page_meta in pages_metadata:
    pdf_page = page_meta.get('page')
    sheet_num = page_meta.get('sheet_number', str(pdf_page))
    if sheet_num and sheet_num != "N/A":
        sheet_to_pdf_mapping[str(sheet_num)] = pdf_page

# Результат: {"АР-03": 5, "КЖ-12": 12, ...}
# Клик на "Лист АР-03" → открывает PDF страницу 5
```

---

## ⚡ Оптимизации

### 1. **Компактные вырезки вместо полных страниц**
- Экономия токенов: ~85% (вместо 1700 токенов → 255 токенов на страницу)
- Фокус на важных областях с метаданными

### 2. **Батчинг запросов**
- До 30 страниц в одном запросе
- Защита от rate limit (30 × 770 = 23,100 токенов < 30,000 TPM)

### 3. **Low detail для вырезок**
- Достаточно для OCR текста штампов
- Дополнительная экономия токенов

### 4. **Fallback механизм**
```python
except Exception as e:
    logger.error(f"❌ [STAGE 1] Ошибка извлечения метаданных: {e}")
    # Fallback: используем номера PDF страниц
    return [{"page": i+1, "sheet_number": f"{i+1}", ...} for i in range(len(crops))]
```

---

## 🎯 Итог

**STAGE 1** - это **самая первая стадия анализа**, которая:

1. ✅ Вырезает 4 ключевые области со страницы
2. ✅ Объединяет их в компактное изображение
3. ✅ Отправляет в Vision API с приоритетным алгоритмом
4. ✅ Извлекает **sheet_number** из штампа (приоритет 1)
5. ✅ Валидирует несовпадения между разными источниками
6. ✅ Возвращает метаданные для использования в STAGE 2 и 3

**Результат:** Каждая PDF страница получает свой `sheet_number` (например: "АР-03"), который затем используется во всех последующих стадиях анализа!

